using UnityEngine;
using UnityEngine.Splines;
using UnityEditor;
using System.Collections.Generic;

[ExecuteInEditMode]
public class SplineGridGenerator : MonoBehaviour
{
    [Header("Settings")]
    public GameObject cubePrefab;
    public LayerMask terrainLayer = -1;

    private SplineContainer splineContainer;
    private Terrain terrain;
    private int cubesGenerated = 0;
    private Bounds lastBounds;

    [ContextMenu("Generate Grid")]
    public void GenerateGridEditor()
    {
        if (!IsSplineValid()) return;

        CleanupExistingGrid();
        FindTerrain();
        CalculateAndPlaceCubes();

        Debug.Log($"Generated {cubesGenerated} cubes");
    }

    [ContextMenu("Clear Grid")]
    public void ClearGrid()
    {
        Transform existingGrid = transform.Find("Grid Cubes");
        if (existingGrid != null)
        {
            DestroyImmediate(existingGrid.gameObject);
            Debug.Log("Grid cleared");
        }
        cubesGenerated = 0;
    }

    private bool IsSplineValid()
    {
        splineContainer = GetComponent<SplineContainer>();

        if (splineContainer == null)
        {
            Debug.LogError("No SplineContainer found!");
            return false;
        }

        if (cubePrefab == null)
        {
            Debug.LogError("Cube prefab is not assigned!");
            return false;
        }

        return true;
    }

    private void FindTerrain()
    {
        terrain = FindFirstObjectByType<Terrain>();
        if (terrain != null)
        {
            Debug.Log($"Found terrain: {terrain.name}");
        }
    }

    private void CleanupExistingGrid()
    {
        List<Transform> toDestroy = new List<Transform>();
        foreach (Transform child in transform)
        {
            if (child.name.Contains("Grid Cube") || child.name == "Grid Cubes")
            {
                toDestroy.Add(child);
            }
        }

        foreach (Transform child in toDestroy)
        {
            DestroyImmediate(child.gameObject);
        }

        cubesGenerated = 0;
    }

    private void CalculateAndPlaceCubes()
    {
        lastBounds = GetWorldSpaceBounds();

        GameObject gridParent = new GameObject("Grid Cubes");
        gridParent.transform.parent = transform;
        gridParent.transform.position = Vector3.zero;

        Vector3 start = lastBounds.min;
        Vector3 end = lastBounds.max;

        const float gridSpacing = 1f;

        int countX = Mathf.CeilToInt((end.x - start.x) / gridSpacing);
        int countZ = Mathf.CeilToInt((end.z - start.z) / gridSpacing);

        for (int x = 0; x <= countX; x++)
        {
            for (int z = 0; z <= countZ; z++)
            {
                Vector3 worldPos = new Vector3(
                    start.x + (x * gridSpacing),
                    0,
                    start.z + (z * gridSpacing)
                );

                worldPos.y = GetGroundHeight(worldPos);

                if (IsPointInsideSpline(worldPos))
                {
                    PlaceCube(worldPos, gridParent.transform);
                    cubesGenerated++;
                }
            }
        }
    }

    private float GetGroundHeight(Vector3 position)
    {
        if (terrain != null)
        {
            Vector3 terrainPos = position;
            terrainPos.y = terrain.transform.position.y + 1000f;

            if (Physics.Raycast(terrainPos, Vector3.down, out RaycastHit hit, 2000f, terrainLayer))
            {
                return hit.point.y;
            }

            return terrain.SampleHeight(position) + terrain.transform.position.y;
        }

        Vector3 rayStart = position + Vector3.up * 1000f;
        if (Physics.Raycast(rayStart, Vector3.down, out RaycastHit hit2, 2000f, terrainLayer))
        {
            return hit2.point.y;
        }

        return transform.position.y;
    }

    private Bounds GetWorldSpaceBounds()
    {
        var spline = splineContainer.Spline;
        List<Vector3> worldPoints = new List<Vector3>();

        for (int i = 0; i < spline.Count; i++)
        {
            Vector3 worldPos = splineContainer.transform.TransformPoint(spline[i].Position);
            worldPoints.Add(worldPos);
        }

        int samples = Mathf.Max(50, spline.Count * 20);
        for (int i = 0; i <= samples; i++)
        {
            float t = i / (float)samples;
            Vector3 worldPos = splineContainer.transform.TransformPoint(
                spline.EvaluatePosition(t)
            );
            worldPoints.Add(worldPos);
        }

        Bounds bounds = new Bounds();
        if (worldPoints.Count > 0)
        {
            bounds = new Bounds(worldPoints[0], Vector3.zero);
            foreach (Vector3 point in worldPoints)
            {
                bounds.Encapsulate(point);
            }
        }

        bounds.Expand(2f);

        return bounds;
    }

    private bool IsPointInsideSpline(Vector3 worldPoint)
    {
        Vector3 localPoint = splineContainer.transform.InverseTransformPoint(worldPoint);
        Vector2 point2D = new Vector2(localPoint.x, localPoint.z);

        Vector2[] polygon = GetSplinePolygon();

        bool inside = false;
        int j = polygon.Length - 1;

        for (int i = 0; i < polygon.Length; i++)
        {
            if (((polygon[i].y > point2D.y) != (polygon[j].y > point2D.y)) &&
                (point2D.x < (polygon[j].x - polygon[i].x) * (point2D.y - polygon[i].y) /
                (polygon[j].y - polygon[i].y) + polygon[i].x))
            {
                inside = !inside;
            }
            j = i;
        }

        return inside;
    }

    private Vector2[] GetSplinePolygon()
    {
        var spline = splineContainer.Spline;
        List<Vector2> points = new List<Vector2>();

        int samples = 300;
        for (int i = 0; i <= samples; i++)
        {
            float t = i / (float)samples;
            Vector3 localPos = spline.EvaluatePosition(t);
            points.Add(new Vector2(localPos.x, localPos.z));
        }

        return points.ToArray();
    }

    private void PlaceCube(Vector3 position, Transform parent)
    {
#if UNITY_EDITOR
        GameObject cube;

        if (PrefabUtility.IsPartOfPrefabAsset(cubePrefab))
        {
            cube = (GameObject)PrefabUtility.InstantiatePrefab(cubePrefab);
        }
        else
        {
            cube = Instantiate(cubePrefab);
        }

        cube.transform.position = position;
        cube.transform.parent = parent;

        const float cubeScale = 0.1f;
        cube.transform.localScale = new Vector3(cubeScale, cubeScale, cubeScale);

        cube.name = $"Grid Cube {cubesGenerated}";

        Undo.RegisterCreatedObjectUndo(cube, "Create Grid Cube");
#endif
    }

    void OnDrawGizmosSelected()
    {
        if (splineContainer == null) return;

        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(lastBounds.center, lastBounds.size);

        Gizmos.color = Color.green;
        var spline = splineContainer.Spline;
        Vector3 lastPos = Vector3.zero;
        bool first = true;

        int samples = 50;
        for (int i = 0; i <= samples; i++)
        {
            float t = i / (float)samples;
            Vector3 worldPos = splineContainer.transform.TransformPoint(
                spline.EvaluatePosition(t)
            );

            if (!first)
            {
                Gizmos.DrawLine(lastPos, worldPos);
            }

            lastPos = worldPos;
            first = false;
        }
    }
}

#if UNITY_EDITOR
[CustomEditor(typeof(SplineGridGenerator))]
public class SplineGridGeneratorEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        SplineGridGenerator generator = (SplineGridGenerator)target;

        EditorGUILayout.Space();

        if (GUILayout.Button("Generate Grid", GUILayout.Height(30)))
        {
            generator.GenerateGridEditor();
        }

        if (GUILayout.Button("Clear Grid"))
        {
            generator.ClearGrid();
        }
    }
}
#endif
